<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ“š</text></svg>"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>German stories</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <header>
      <a href="/">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="32"
          height="32"
          viewBox="0 0 256 256"
          class="logo"
        >
          <path
            d="M100,56H40A16,16,0,0,0,24,72v64a16,16,0,0,0,16,16h60v8a32,32,0,0,1-32,32,8,8,0,0,0,0,16,48.05,48.05,0,0,0,48-48V72A16,16,0,0,0,100,56Zm0,80H40V72h60ZM216,56H156a16,16,0,0,0-16,16v64a16,16,0,0,0,16,16h60v8a32,32,0,0,1-32,32,8,8,0,0,0,0,16,48.05,48.05,0,0,0,48-48V72A16,16,0,0,0,216,56Zm0,80H156V72h60Z"
            fill="currentColor"
          ></path>
        </svg>
      </a>
      <nav>
        <a href="/a1.html">A1</a>
        <a href="/a2.html">A2</a>
        <a href="/b1.html">B1</a>
        <a href="/b2.html">B2</a>
      </nav>
      <button id="toggle-dark-mode">Light</button>
    </header>

    <section class="main-content">
      <aside>
        <nav id="toc">{{toc}}</nav>
      </aside>
      <main>{{content}}</main>
    </section>

    <button id="back-to-top" title="Back to top">â†‘</button>
    <footer>
      <div>
        <p>
          Crafted by
          <a target="_blank" href="https://danielbergmann.ch"
            >Daniel Bergmann</a
          >
        </p>
        <p>&copy; <span id="current-year"></span> - All rights reserved.</p>
      </div>
    </footer>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const darkModeButton = document.getElementById("toggle-dark-mode")
        const body = document.body
        const backToTopButton = document.getElementById("back-to-top")

        // Check dark mode preference
        const darkModeEnabled = localStorage.getItem("dark-mode") === "true"

        // Set initial theme and button text
        if (darkModeEnabled) {
          body.setAttribute("data-theme", "dark")
          darkModeButton.textContent = "Light"
        } else {
          darkModeButton.textContent = "Dark"
        }

        // Toggle dark mode on button click
        darkModeButton.addEventListener("click", () => {
          if (body.getAttribute("data-theme") === "dark") {
            body.removeAttribute("data-theme")
            localStorage.setItem("dark-mode", "false")
            darkModeButton.textContent = "Dark"
          } else {
            body.setAttribute("data-theme", "dark")
            localStorage.setItem("dark-mode", "true")
            darkModeButton.textContent = "Light"
          }
        })

        // Back to Top Button Functionality
        window.addEventListener("scroll", () => {
          if (window.scrollY > 200) {
            backToTopButton.style.display = "block"
          } else {
            backToTopButton.style.display = "none"
          }
        })

        backToTopButton.addEventListener("click", () => {
          window.scrollTo({ top: 0, behavior: "smooth" })
        })

        // Set current year in footer
        const yearSpan = document.getElementById("current-year");
        const currentYear = new Date().getFullYear();
        yearSpan.textContent = currentYear;

        // Smooth scrolling for Table of Contents
        document.querySelectorAll('#toc a').forEach(link => {
          link.addEventListener('click', event => {
            event.preventDefault(); // Prevent default anchor click behavior

            const targetId = link.getAttribute('href').substring(1); // Get target ID
            const targetElement = document.getElementById(targetId);

            if (targetElement) {
              const headerOffset = 135; // Adjust this value based on header's height
              const elementPosition = targetElement.getBoundingClientRect().top + window.scrollY;
              const offsetPosition = elementPosition - headerOffset;

              window.scrollTo({
                top: offsetPosition,
                behavior: 'smooth'
              });
            }
          });
        });

      const mainContent = document.querySelector("main");

      // Initialize variables to manage speech synthesis state
      let speechQueue = []; // Queue to hold chunks of text to be spoken
      let isSpeaking = false; // Flag to indicate if speech synthesis is active
      let currentButton = null; // Reference to the currently active voice button
      let cancelInitiated = false; // Flag to indicate if speech synthesis cancellation is in progress

      // Check if the main content section exists
      if (mainContent) {
      const stories = mainContent.querySelectorAll("h2");

      // Iterate through each story heading to add a voice button
      stories.forEach((heading) => {
        const voiceButton = document.createElement("button");
        voiceButton.textContent = `Listen to Story: ${heading.textContent.trim()}`;
        voiceButton.classList.add("voice-button");

        // Add click event listener to the voice button
        voiceButton.addEventListener("click", () => {
          if (!('speechSynthesis' in window)) {
            alert("Speech synthesis is not supported in your browser.");
            return;
          }

          // Handle stopping the current story if already playing
          if (currentButton === voiceButton && isSpeaking) {
            cancelInitiated = true;
            window.speechSynthesis.cancel();
            isSpeaking = false;
            currentButton.textContent = `Listen to Story: ${heading.textContent.trim()}`;
            speechQueue.length = 0;
            return;
          }

          // Handle starting a new story
          if (isSpeaking) {
            cancelInitiated = true;
            window.speechSynthesis.cancel();
            speechQueue = []; // Reset the queue for the new story
            isSpeaking = false; // Update speaking flag
            if (currentButton) {
              currentButton.textContent = `Listen to Story: ${currentButton.dataset.storyName}`;
            }
          }

          // Set the current button and update its text
          currentButton = voiceButton;
          currentButton.dataset.storyName = heading.textContent.trim();
          currentButton.textContent = "Stop Listening";

          // Extract the story text and split it into manageable chunks
          const storyText = extractStoryText(heading);
          speechQueue = splitTextIntoChunks(storyText, 200);
          speakNextChunk();
          });

        heading.style.display = "inline-block";
        heading.style.marginLeft = "10px";
        heading.insertAdjacentElement("beforebegin", voiceButton);
      });
      }

      function extractStoryText(heading) {
        let storyText = heading.textContent.trim();
        let sibling = heading.nextElementSibling;

        // Traverse siblings until another heading (H2) is encountered
        while (sibling && sibling.tagName !== "H2") {
          if (sibling.tagName === "P") {
            storyText += ` ${sibling.textContent.trim()}`;
          }
        sibling = sibling.nextElementSibling;
        }

        return storyText;
      }

      //Speak the next chunk of text from the speech queue.
      function speakNextChunk() {
        if (!speechQueue.length) {
        isSpeaking = false; // Update speaking flag
        if (currentButton) {
          currentButton.textContent = `Listen to Story: ${currentButton.dataset.storyName}`;
        }
        return;
      }

      // Get the next chunk from the queue and create an utterance
      const chunk = speechQueue.shift();
      const utterance = new SpeechSynthesisUtterance(chunk);
      utterance.lang = "de-DE";

      // Event listener for when the current chunk finishes
      utterance.onend = () => {
        if (!cancelInitiated) {
          speakNextChunk();
        } else {
          cancelInitiated = false; // Reset cancellation flag
        }
      };

      // Event listener for handling errors during speech synthesis
      utterance.onerror = (error) => {
        console.error("Speech synthesis error:", error.error);

        if (!cancelInitiated) {
          alert("An error occurred while trying to play the story.");
        }

        cancelInitiated = false;
        isSpeaking = false; // Update speaking flag
        if (currentButton) {
          currentButton.textContent = `Listen to Story: ${currentButton.dataset.storyName}`;
        }
      };

      // Start speaking the current chunk
      isSpeaking = true;
      window.speechSynthesis.speak(utterance);
      }


      //Split a large block of text into smaller chunks for speech synthesis.
      //Ensures that each chunk does not exceed the specified maximum length.
      function splitTextIntoChunks(text, maxLength) {
        const sentences = text.split(/([.!?])/);
        const chunks = [];
        let currentChunk = "";

        // Combine sentences into chunks while respecting the maximum length
        sentences.forEach((sentence) => {
          if (currentChunk.length + sentence.length <= maxLength) {
            currentChunk += sentence;
          } else {
            chunks.push(currentChunk.trim());
            currentChunk = sentence;
          }
        });

        // Add the last chunk if any text remains
        if (currentChunk) {
          chunks.push(currentChunk.trim());
        }

        return chunks;
      }
      });
    </script>
  </body>
</html>